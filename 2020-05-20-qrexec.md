This is a second article in the "what's new in Qubes 4.1" series. You can find the previous one (about GUI Domain) [here](https://www.qubes-os.org/news/2020/03/18/gui-domain/). While GUI domain is a big, singular feature, the changes to qrexec are more complex and varied – but also very important.

# What is qrexec?

You might have been using Qubes for a while and never encountered the word 'qrexec' – but it is one of the crucial components of the system. Qubes provides isolation and compartmentalization; separate qubes are separate worlds and what the user does in one qube should not impact another qube. That is of course not realistic – in the real world, we often need and want to do things like copying and pasting, sending files, routing internet traffic or even synchronizing the date. This is when qrexec comes in: it is an rpc (remote procedure call) mechanism that allows one qube to do something inside another qube. Of course allowing everything at every time would be extremely dangerous – thus a part of qrexec called qrexec policy is also used to enforce who can do what and where. Furthermore, we want to be able to audit what was done, and this is provided with the logging capabilities of qrexec. The how is controlled by qrexec-services, which are executed by qrexec and also must be designed in a secure and resilient way. This post is focused mostly on qrexec itself, but qrexec-services will make a brief appearance.

# Overview of changes

Before we get into nitty-gritty technical details (and a big part of this post will be very technical – if you don't care about writing your own policy or qrexec services, feel free to just read this overview), here's a brief, less technical overview of Qubes 4.1 qrexec changes (and what do they mean for users and developers):

- a new qrexec policy format (the old format is still supported, but the new one is very much superior, allowing for easier-to-read policy, more qube-centered customization, better auditing and more),
- big performance improvements: bigger data chunk size for faster transfer of huge amounts of data, qrexec policy daemon for faster policy evaluation and call setup, leading to up to sevenfold faster qrexec service calls
- support for socket services: better performance for services who can use a socket-based implementation, with significantly faster setup and connection times,
- policy notifications, to make any abnormal behavior easier to detect and problems resulting from incorrect permissions easier to solve,

One other incoming big change is not yet fully implemented and will not come in Qubes 4.1, but still merits mentioning: we are working on qrexec policy API, that is, a set of qrexec services that will allow managing qrexec policy without manually editing policy files. It's another step in separating the user from dom0 and containing as much of the vulnerable system insides as far away from any interference as possible. 

# New policy format

In Qubes 4.0 and before, policy was stored as multiple files, one per service. While changing permissions for a single action was easy, managing permissions for an entire qube was very cumbersome. The new Qubes 4.1 policy format, completely overhauls this approach and introduces several convenience features and changes to make policy easier to use and more secure. 

If you feel a tinge of panic – what about my carefully-prepared 4.0 policies? Do I have to rewrite them? – don't worry. The old policy format is still supported, and will be supported until at least Qubes 5.0.

You can find details about the development of the new policy format [here](https://github.com/QubesOS/qubes-issues/issues/4370):

## Policy files

The biggest difference is that 4.1 policy is a single entity. It is not divided into separate, independent, per-service fragments – and while it can be stored in multiple files, located in multiple places, the files are equivalent and each can describe policies for multiple services. In other words, we are moving from a set of tables to one big, flat table.

The policy files, stored previously in `/etc/qubes-rpc/policy`, are now located in `/etc/qubes/policy.d`. Furthermore, each file must have a '.policy' extension – any temporary files will no longer cause issues. In the old format, there were dozens files :

```
/etc/qubes-rpc/policy
├── admin.backup.Cancel
├── admin.backup.Execute
├── admin.backup.Info
├── include
│   ├── admin-local-ro
│   ├── admin-local-rwx
│   ├── admin-global-ro
│   ├── admin-global-rwx
├── …
├── qubes.Gpg
├── qubes.StartApp
├── …
├── whonix.SdwdateStatus
```

In the new policy, we simply have:

```
/etc/qubes/policy.d/
├── 35-compat.policy
├── 90-admin-default.policy
├── 90-default.policy
├── include
│   ├── admin-local-ro
│   ├── admin-local-rwx
│   ├── admin-global-ro
│   ├── admin-global-rwx
(and any additional user-defined files)
```

Example old policy file (`qubes.GetDate.policy`):

```
## Note that policy parsing stops at the first match,
## so adding anything below "$anyvm $anyvm action" line will have no effect

## Please use a single # to start your custom comments

$tag:anon-vm	$anyvm	deny
$anyvm	$anyvm	allow,target=dom0
```

Beginning of an example new policy file (`90-default.policy`):
```
 ## Do not modify this file, create a new policy file with lower number in the
## filename instead. For example `30-user.policy`.

###
### Default qrexec policy
###

## File format:
## service-name|*       +argument|* source          destination action  [options]

## Note that policy parsing stops at the first match.

# policy.RegisterArgument should be allowed only for specific arguments.
policy.RegisterArgument *           @anyvm          dom0        deny

# WARNING: The qubes.ConnectTCP service is dangerous and allows any
# qube to access any other qube TCP port. It should be restricted
# only to restricted qubes. This is why the default policy is 'deny'

# Example of policy: qubes.ConnectTCP +22 mytcp-client @default allow,target=mytcp-server
qubes.ConnectTCP        *           @anyvm          @anyvm      deny

# VM advertise its supported features
qubes.FeaturesRequest   *           @anyvm	        dom0	    allow

# Windows VM advertise installed Qubes Windows Tools
qubes.NotifyTools       *           @anyvm          dom0        allow

# File copy/move
qubes.Filecopy          *           @anyvm          @anyvm      ask

# Get current date/time
qubes.GetDate           *           @tag:anon-vm    @anyvm      deny
qubes.GetDate           *           @anyvm          @anyvm      allow target=dom0
```

Now policy for a single qube is much easier to find, parse and edit. It can all be contained in a single file, and by using wildcards (see below) it can be much more readable and easy to understand. For example, it's trivial now to "forbid all calls" for a given qube – or forbid all, and provide a list of exceptions. This allows a more qube-centric approach to policy, and while the results are theoretically the same, there's a huge difference between a couple of rules, all in one places, and dozens or rules spread over dozens of files. It's especially important for Admin API policies (Admin API provides qrexec calls for querying system state – there is a lot of them, they are needed by system qubes such as a GUI domain and it was quite arduous to edit them when each call had its own policy file).

On the other side, now the policy is a single whole – it is parsed as a whole and if there are any syntax errors, the parser will refuse to load anything (in order to prevent any unintended permission grants). An empty policy leads to all qrexec calls being denied, which makes for a system that's not exactly easy to use. You should always edit policy carefully! It's the same approach as tools such as `sudo` use, and we decided it makes, as a whole, for a safer system. In the future, Qubes will also include a Policy API (see below) that will include calls modifying the policy in a safe and syntax-error-preventing way, but it is still in development.

## New column syntax

Full specification can be found [here](https://github.com/QubesOS/qubes-core-qrexec/blob/master/Documentation/multifile-policy.markdown):

Old policy files had three columns: source qube, target qube and action (allow/deny/ask), with optional arguments. Because the new policy format no longer carries the information about service name in the file name, we had to change this a bit to a five-column format: service name, service argument, source qube, target qube and action:

```
qrexec.Service +ARGUMENT SRCQUBE DSTQUBE {allow|deny|ask} [PARAM=VALUE [PARAM=VALUE ...]]
```

As before, you can use wildcards – but now you can also use them in the service name and argument fields (not only in source qube and target qube fields, as before). For example, to forbid all calls from a qube called work to a qube called personal, you could use this line:

```
* * work personal deny
```

You could also deny all calls from a qube called work, except for calls to dom0, which would be allowed:

```
* * work dom0 allow
* * work * deny
```

This, together with the new file structure, allows you to have much more readable and clearer qube-centered policy rules.

A minor change is replacing commas with spaces in the parameter list, so, for example, a ConnectTCP policy could look like this:

```
qubes.ConnectTCP * mytcp-client @default allow target=mytcp-server
```

## Security in symbols

Old policy format used the `$` character in multiple keywords, such as `$default`, `$dispvm` etc. Due to a potential issue described in [Qubes Security Bulletin #38](https://www.qubes-os.org/news/2018/02/20/qsb-38/) (in brief, interaction of Bash shell parameter expansion and `$` characters in policy files could theoretically lead to security problems) we have been getting rid of `$`. For backwards compatibility, it is still supported in policy files, but it is being internally turned into a `@` before processing – and in the new policy format, we only use `@`. What was `$default` in Qubes 4.0 will now be `@default`, `$dispvm` turns into `@dispvm`, and so on. For example, to update all TemplateVMs through sys-whonix, you would use:

```
qubes.UpdatesProxy * @type:TemplateVM @default allow target=sys-whonix
```

In all client tools, `$` will still be automatically translated into `@` (so you don't have to change any existing scripts) – but obviously we highly recommend using only `@`. We will stop providing legacy `$` support only in Qubes 5.0.

## Includes

The old format supported a simple `$include` directive; in 4.1, the include capabilities are extended, and now we have four kinds of includes. Due to above-mentioned QSB#38 change, the keywords no longer start with `$`, but rather with an exclamation point `!`. The supported include directives are:

- `!include path_to_file` - the simplest command that includes the whole contents of the file and parses it according to new policy syntax rules. The file can contain policy rules for one or more services, for one or more qubes.
- `!include-dir path_to_directory` - it includes all .policy files from the directory, parsing them according to new policy syntax rules.
- `!include-service service argument path_to_file` - this directive allows you to include a policy in a format similar to the old one (without service and argument), by filling in the missing service and argument fields from the new format with parameters provided to `include-service`. Either of those (or both) can be a wildcard `*`, as they can be in all new policy files. It may seem like a directive useful only for backwards compatibility, but in fact it also has uses in the Admin API policies used for – among others – implementing GUI domains.
- `!compat-4.0` - this is an explicit backwards compatibility directive that takes the old policy files from their old locations and converts them internally (using `include-service`) to be a part of the new policy.

## Backwards compatibility

One of the new policy files is `35-compat.policy` – it loads the old policy files and parses them in a way compatible with the new policy format.

Before the old policy format is completely phased out in Qubes 5.0, we will provide a conversion tool, but it may not be available in Qubes 4.1 on release. Due to legacy support for old policy format with the `35-compat.policy` and the `!compat-4.0` include directive, at least for Qubes 4.1 it's not yet strictly necessary for users to update their custom policies in any way.

# Performance improvements

## Bigger and better

In 4.1, max qrexec data chunk size has been increased from 4kB to 64kB. This makes large data transfers – for example copying big files or streaming video through `qvm-usb` from sys-usb to a qube with a video call ongoing – significantly faster (details can be found [here](https://github.com/QubesOS/qubes-issues/issues/4909)).

We have also significantly increased the maximum service and argument length. In Qubes 4.0, it was just 63 characters for the combined service+arguments. Now, it is 65 000 characters (a bit less than 64kB, due to an internal header). The main reason for this change – apart from sheer convenience – is the `qubes.VMShell` service. It's an extremely dangerous service that gives complete shell access. Unsurprisingly, it's not allowed by default. `qubes.VMShell` just provides a shell stdin/stdout, so in Qubes 4.0 handling it with a single command was extremely cumbersome and often required prodigious amounts of quotation marks. What was even worse, the command was not stored in any logfile, and policy did not control what commands could be executed, opening up a big, non-auditable, dangerous space for exploitation. By increasing the service+argument length (and putting the argument into policy, as described above), we are able to introduce a new, more accountable and safer service in Qubes 4.1. `qubes.VMExec`, as it is called, is logged complete with its argument (that is, the command to be executed), can be controlled with great precision (policy can allow only certain commands, not everything that can be executed in shell), and has all arguments explicitly defined and unambiguous, freeing the user from quotation mark purgatory (the syntax is described [here](https://www.qubes-os.org/doc/vm-interface/#qubes-rpc)). Other services will also profit, such as the U2F implementation that, due to previous limitations, required some awkward wrangling of the public key hash. (details can be found [here](https://github.com/QubesOS/qubes-issues/issues/4850)).

There are also some minor improvements and streamlining incoming: for example, a new call that allows to access all qube properties at once, which allows `qvm-ls` (and similar tools) to work significantly faster. Instead of making about 5 Admin API calls per qube, `qvm-ls` will now only make one, leading to a fivefold speed increase.

## Policy daemon

In Qubes 4.0, performing a qrexec call (with all its assorted policy checking) was a fairly slow process. Even in a best case (simple allow, no asking user for input), it consistent of several processes: loading the whole policy again, loading Python modules required to parse it, executing the call itself… The setup itself took about 300 ms (for a typical system). In case of rare operations, such as copying a file, it's hardly a problem – but for frequent operations it could be a disaster. Tunneling a TCP connection via qrexec (the `qubes.ConnectTCP` service) would mean a 300 ms lag for establishing the connection. A complete nightmare for the server! Qubes Clipboard, which also uses qrexec and is managed by a policy (which allows to block copy or paste for certain qubes), need 300 ms for each operation, which can be a bit of a problem for particularly fast typists. The biggest problem was, however, the Admin API. The whole idea of an Admin API (read more [here](https://www.qubes-os.org/news/2017/06/27/qubes-admin-api/)) requires a lot of qrexec calls. If we want to implement a GUI domain that manages certain parts of the system instead of having the user directly access dom0, we need Admin API to be much, much faster. For example, without the changes outlined below, starting Qube Manager on a default, out of the box Qubes configuration with a GUI domain took 37 seconds. This is just unacceptable.

To speed up qrexec calls, Qubes 4.1 introduces a policy daemon.  It is a process that loads the policy into memory and keeps it there (only reloading when policy files change), answering qrexec queries about whether a given operation should be accepted or denied without spawning new processes or loading more files and Python modules. The results are quite satisfying – Qube Manager start in a default system configuration with a GUI domain takes less than 5 seconds, for a more than sevenfold improvements.

## Socket services

Another problematic bottleneck for qrexec was that each service was a new process. In several cases, this process just connects to an existing service. A particularly egregious example is Admin API: an Admin API call is just a connection to dom0's qubesd daemon, but in Qubes 4.0 each of its calls was a separate process, going through a bunch of shell scripts to return a simple chunk of data. For a program like `qvm-ls` that needs to access a lot of data from Admin API, it was a performance nightmare.

A qrexec service is a file residing in `/etc/qubes-rpc`. In Qubes 4.0, it must be an executable or a symlink to one; in Qubes 4.1, it can also be a symlink to a unix socket. Via this socket, you can simply connect to an existing process that will handle your call. With each socket connection, this running service receives a new connection with a metadata header (containing information on who wants to do what and where, a service name just in case, and a terminating 0 byte) followed by the same client data as before. Thus even though it's a single process that handles multiple calls, it knows where each call came from and what it asked for.

Performance gains on both speed and memory benchmarks are really significant. Converting icon rendering (the service that is responsible for making sure your program icons are colored with the colors of their qube) into a socket-based service led to turning separate per-qube processes in dom0, each one loading Gtk and other libraries for about 32MB of RAM, into a single process. Now ten running qubes need only this one socket-based service process, for a single instance of 32MB RAM usage, instead of Qubes 4.0's ten times that. Admin API also uses a socket service, which – combined with the policy daemon described above – dropped call execution time from 300 ms to about 50 ms. 

More information about socket services can be found [here](https://github.com/QubesOS/qubes-issues/issues/3912).

# Notifications

Creating a qrexec policy daemon opened another convenient opportunity: adding notifications to some policy actions. By default, notifications are shown only when a deny occurs (unless it was due to an ask action: if the user was already asked for consent, it is not necessary to show the notification), but the new policy format allows for an optional `notify=no` parameter with deny rules. Allow rules support a `notify=yes` parameter that will show a notification also on accepted qrexec calls.  

![Screenshot of an allow and a deny notifications](qrexec-notification.png)
 
For example, this rule will cause notifications to be shown whenever a VM.exec service call is made from work qube to personal qube:

```
qubes.VM.exec * work personal allow notify=yes
```

And the above screenshot could be accomplished with:

```
qubes.Gpg * work work-gpg allow notify=yes
qubes.Filecopy * untrusted * deny
```

Notifications alert the user that something unexpected might have happened – they can signal a misconfigured policy (when calls are denied while the user would prefer them to be allowed) or a misbehaving or malicious qube (when unexpected calls are being made and denied due to correctly configured policy).

Introducing a GUI domains makes the subject of qrexec notifications a bit more complex. After all, there can be more than one GUI domain – which one should receive notifications? At the moment, we decided that the GUI domain serving the source qube (the one making the call) will show notifications. There are some conceivable setups in which some other GUI domain should show notifications, but Qubes 4.1 will not be supporting it; however, it may appear in some future version.

More information about notifications can be found [here](https://github.com/QubesOS/qubes-issues/issues/3904).

# Policy API (in development)

As has been mentioned before, one of our big development goals is separating the user from the most vulnerable part of the system: dom0. It will improve compartmentalization and security and lower both the attack surface and the chance of accidentally committing a compromising mistake.

For complete separation from dom0, however, we need to provide qrexec interfaces for everything that may need access and configuration – including qrexec policy itself. At the moment, we are working on a broad Policy API, one allowing editing the whole policy without supporting a limited users with access only to parts of it. Policy API will also enforce correctness of policy changes, avoiding problems mentioned in the "New policy format" above: the user will not be able to create syntactically incorrect policy rules.

We have some ideas on implementing limited access (for example having someone allowed only to change access to certain qubes or to certain services), but the design is not yet final. In its current state, we are thinking about supporting two kinds of roles: an API administrator with total access, and an operator, with access to only a well-defined subset of the policy. However, implementation of any such ideas will definitely not be a part of Qubes 4.1.

Current work on Policy API design draft and a proof of concept can be found [here](https://github.com/QubesOS/qubes-policy-control).

